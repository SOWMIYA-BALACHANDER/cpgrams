"""
Hierarchical Entity Manager
---------------------------
Interactive CLI tool for inserting hierarchical entity data into PostgreSQL.
Depth-first traversal with yes/no driven sub-entity expansion and bulk inserts.

Usage:
    python main.py

Fields Inserted:
    - id (auto-generated by DB)
    - name (user input)
    - entity_type (default: CENTRAL_GOVERNMENT)
    - parent_entity_id (hierarchy mapping)
"""

import sys
import os
from typing import List

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from utils.db_connection import DatabaseConnection


def get_positive_integer(prompt: str) -> int:
    """Get a positive integer from user input."""
    while True:
        try:
            value = int(input(prompt).strip())
            if value > 0:
                return value
            print("  ⚠ Please enter a positive number.")
        except ValueError:
            print("  ⚠ Invalid input. Please enter a valid number.")


def get_non_empty_string(prompt: str) -> str:
    """Get a non-empty string from user input."""
    while True:
        value = input(prompt).strip()
        if value:
            return value
        print("  ⚠ Input cannot be empty. Please try again.")


def get_yes_no(prompt: str) -> bool:
    """Get a yes/no response from user."""
    while True:
        value = input(prompt).strip().lower()
        if value in ('y', 'yes'):
            return True
        if value in ('n', 'no'):
            return False
        print("  ⚠ Please enter 'y' or 'n'.")


def collect_entity_names_multiline(count: int, indent: str) -> List[str]:
    """
    Collect entity names via multi-line input (paste all at once).
    
    Args:
        count: Expected number of entities
        indent: Indentation for display
    
    Returns:
        List of entity names
    """
    while True:
        print(f"{indent}--- Paste {count} entity names below (one per line) ---")
        print(f"{indent}--- Press ENTER twice when done ---")
        
        lines = []
        empty_line_count = 0
        
        while True:
            try:
                line = input()
                if line.strip() == "":
                    empty_line_count += 1
                    if empty_line_count >= 1:  # One empty line to finish
                        break
                else:
                    empty_line_count = 0
                    lines.append(line.strip())
            except EOFError:
                break
        
        # Filter out empty lines
        names = [line for line in lines if line]
        
        # Validate count
        if len(names) != count:
            print(f"{indent}⚠ Expected {count} entities, but got {len(names)}.")
            print(f"{indent}  Please re-enter all {count} names.")
            continue
        
        # Display parsed names
        print(f"{indent}✓ {count} entities parsed:")
        for i, name in enumerate(names, 1):
            print(f"{indent}  {i}. {name}")
        
        return names


def process_sub_entities_depth_first(db: DatabaseConnection,
                                     entities: List[dict], level: int):
    """
    Process sub-entities in depth-first order.
    For each entity, ask if sub-entities exist, then go deep before moving to siblings.
    
    Args:
        db: Database connection
        entities: List of dicts with 'id' and 'name' keys
        level: Current depth level
    """
    indent = "  " * level
    
    for idx, entity in enumerate(entities, 1):
        entity_name = entity['name']
        entity_id = entity['id']
        
        print(f"\n{indent}[{idx}/{len(entities)}] Processing: '{entity_name}'")
        
        # Ask if sub-entity is available
        has_sub = get_yes_no(f"{indent}Is sub-entity available for \"{entity_name}\"? (y/n): ")
        
        if has_sub:
            # Get count of sub-entities
            sub_count = get_positive_integer(f"{indent}Enter number of sub-entities: ")
            
            # Collect all sub-entity names via multi-line input
            sub_names = collect_entity_names_multiline(sub_count, indent)
            
            # Bulk insert all sub-entities
            print(f"{indent}Inserting {sub_count} sub-entities...")
            sub_ids = db.bulk_insert_entities(
                entities=sub_names,
                parent_entity_id=entity_id
            )
            
            # Create list of inserted sub-entities with IDs
            inserted_subs = []
            for i, name in enumerate(sub_names):
                sub_id = sub_ids[i]
                inserted_subs.append({'id': sub_id, 'name': name})
                print(f"{indent}  ✓ Inserted: '{name}' (ID: {sub_id})")
            
            # Recursively process sub-entities (depth-first)
            process_sub_entities_depth_first(
                db=db,
                entities=inserted_subs,
                level=level + 1
            )
        else:
            print(f"{indent}  → No sub-entities for '{entity_name}'")


def main():
    """Main entry point for the entity manager."""
    print("\n" + "=" * 60)
    print("   HIERARCHICAL ENTITY MANAGER")
    print("   Depth-First | Yes/No Driven | Bulk Insert")
    print("=" * 60)
    print("\n   Fields: name, entity_type (CENTRAL_GOVERNMENT), parent_entity_id")
    print("   Note: id is auto-generated by database")
    
    # Initialize database connection
    db = DatabaseConnection()
    
    if not db.connect():
        print("\n✗ Could not establish database connection. Exiting.")
        sys.exit(1)
    
    try:
        # Step 1: Get top-level entities
        print("\n" + "=" * 60)
        print("STEP 1: Top-Level Entities")
        print("=" * 60)
        
        top_count = get_positive_integer("Enter number of entities: ")
        
        # Collect all top-level entity names via multi-line input
        top_names = collect_entity_names_multiline(top_count, "")
        
        # Bulk insert top-level entities (parent_entity_id = NULL)
        print(f"\nInserting {top_count} top-level entities...")
        top_ids = db.bulk_insert_entities(
            entities=top_names,
            parent_entity_id=None
        )
        
        # Create list of inserted entities with IDs
        inserted_top = []
        for i, name in enumerate(top_names):
            entity_id = top_ids[i]
            inserted_top.append({'id': entity_id, 'name': name})
            print(f"  ✓ Inserted: '{name}' (ID: {entity_id})")
        
        # Step 2: Process each top-level entity depth-first
        print("\n" + "=" * 60)
        print("STEP 2: Sub-Entity Expansion (Depth-First)")
        print("=" * 60)
        
        process_sub_entities_depth_first(
            db=db,
            entities=inserted_top,
            level=1
        )
        
        # Confirm and commit
        print("\n" + "=" * 60)
        confirm = get_yes_no("Commit all changes to database? (y/n): ")
        
        if confirm:
            db.commit()
            print("\n✓ All entities have been successfully inserted!")
        else:
            db.rollback()
            print("\n✓ All changes have been rolled back. No data saved.")
    
    except KeyboardInterrupt:
        print("\n\n⚠ Operation cancelled by user.")
        db.rollback()
    
    except Exception as e:
        print(f"\n✗ An error occurred: {e}")
        db.rollback()
    
    finally:
        db.disconnect()
        print("\n" + "=" * 60)
        print("   Thank you for using Entity Manager!")
        print("=" * 60 + "\n")


if __name__ == "__main__":
    main()
